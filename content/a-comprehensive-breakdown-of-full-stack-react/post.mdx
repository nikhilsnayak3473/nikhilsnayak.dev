import cineScoreThumbnail from './cine-score-thumbnail.png';
import { RSCPayload } from './rsc-payload.tsx';

## Introduction

Yes, you might have already guessed it from the title, we are finally diving deep into [**React Server Components**](https://react.dev/reference/rsc/server-components). Since React 19 is finally stable no more noise about RSCs being experimental, canary, or any of that.

We'll explore React's full-stack architecture by building a simple full-stack app called **Cine Score**. In this app, users can browse a list of movies, up-vote or down-vote a movie, and search through the collection. Here's a sneak peek at what we'll create:

<Image src={cineScoreThumbnail} alt='Cine Score thumbnail' />

Not excited yet? ðŸ¤” What if I told you we'd build this app _without_ using any frameworks? Sounds exciting, right? ðŸŽ‰ Get ready, because we're going to rely solely on the tools provided by React and a few helper libraries.

By the end of this post, I aim to give you a _solid_ understanding of how RSC frameworks work under the hood. This way, you'll be able to use these frameworks wisely instead of fighting them.

> **Disclaimer:** All the code and implementation details discussed in this post are for educational purposes only and are not intended for production use. If you are already familiar working with RSCs in frameworks like Next.js it would help a lot understanding this deep dive

## Project Setup

Weâ€™ll start with a clean slate and build everything step by step. For simplicity, we wonâ€™t be using TypeScript. If youâ€™d like to follow along, make sure you have the latest **LTS** version of Node.js installed.

Letâ€™s create a new Node.js project:

```bash
mkdir cine-score && cd cine-score && npm init -y
```

Install the following dependencies:

```bash
npm install express react react-dom webpack @babel/core @babel/register @babel/preset-react @babel/transform-modules-commonjs babel-loader
```

<CollapsibleContent summary="Overview of each dependency's role:">

- **webpack**: A bundler used to compile JavaScript for the browser.

- **@babel/core**: The core Babel library used to transform JSX into browser-compatible JavaScript.

- **@babel/register**: A runtime helper for Babel that enables on-the-fly transpilation of ES6+ and JSX in Node.js without pre-compilation.

- **@babel/preset-react**: A Babel preset for transpiling JSX and React-specific syntax into JavaScript.

- **@babel/transform-modules-commonjs**: A Babel plugin that transforms ES module syntax (`import`/`export`) into CommonJS (`require`/`module.exports`) for Node.js compatibility.

- **babel-loader**: A Webpack loader that integrates Babel to transpile JavaScript files during the build process.

</CollapsibleContent>

## Fizz - Traditional React SSR

Let's bootstrap the app in the traditional SSR way, as we've been doing since the early days of Next.js.

Hereâ€™s the folder structure and the files in the SSR version:

```
cine-score/
â”œâ”€â”€ package.json
â”œâ”€â”€ build.js       # Build script
â”œâ”€â”€ client.js      # Client-side logic
â”œâ”€â”€ app.js         # Main application entry point
â”œâ”€â”€ search.js      # Component: search functionality
â”œâ”€â”€ movie-list.js  # Component: movie listing
â”œâ”€â”€ vote.js        # Component: voting functionality
â””â”€â”€ server.js      # Server-side logic
```

<Tabs defaultValue='package.json'>

<ScrollArea className='w-full'>
  <TabsList>
    <TabsTrigger value='package.json'>package.json</TabsTrigger>
    <TabsTrigger value='build.js'>build.js</TabsTrigger>
    <TabsTrigger value='client.js'>client.js</TabsTrigger>
    <TabsTrigger value='app.js'>app.js</TabsTrigger>
    <TabsTrigger value='search.js'>search.js</TabsTrigger>
    <TabsTrigger value='movie-list.js'>movie-list.js</TabsTrigger>
    <TabsTrigger value='vote.js'>vote.js</TabsTrigger>
    <TabsTrigger value='server.js'>server.js</TabsTrigger>
  </TabsList>
  <ScrollBar orientation='horizontal' />
</ScrollArea>

<TabsContent value='package.json'>

```json
{
  "name": "cine-score",
  "scripts": {
    "build": "node build.js",
    "server": "node server.js",
    "start": "npm run build && npm run server"
  },
  "dependencies": {
    "@babel/core": "^7.26.0",
    "@babel/plugin-transform-modules-commonjs": "^7.26.3",
    "@babel/preset-react": "^7.26.3",
    "@babel/register": "^7.25.9",
    "babel-loader": "^9.2.1",
    "express": "^4.21.2",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "webpack": "^5.97.1"
  }
}
```

</TabsContent>

<TabsContent value='build.js'>

```js
const path = require('path');
const webpack = require('webpack');

const builder = webpack({
  mode: process.env.NODE_ENV ?? 'development',
  entry: path.resolve(__dirname, './client.js'),
  output: {
    path: path.resolve(__dirname, './dist'),
    filename: 'client.js',
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: [
              [
                '@babel/preset-react',
                {
                  runtime: 'automatic',
                },
              ],
            ],
          },
        },
      },
    ],
  },
});

builder.run((err) => {
  if (err) console.error('Webpack Build Failed', err);
});
```

</TabsContent>

<TabsContent value='client.js'>

```js
import ReactDOMClient from 'react-dom/client';

import { App } from './app';

function hydrateDocument() {
  ReactDOMClient.hydrateRoot(document, <App />);
}

hydrateDocument();
```

</TabsContent>

<TabsContent value='app.js'>

```js
import { useState } from 'react';

import { MoviesList } from './movie-list';
import { Search } from './search';

const initialMovies = [
  { votes: 0, id: 1, title: 'The Dark Knight' },
  { votes: 0, id: 2, title: 'Interstellar' },
  // ...............
];

export function App() {
  const [movies, setMovies] = useState(initialMovies);
  const [query, setQuery] = useState('');

  const voteFn = (formData) => {
    const id = Number(formData.get('id'));
    const type = formData.get('type');

    setMovies((prev) => {
      return prev.map((movie) => {
        if (movie.id === id) {
          return {
            ...movie,
            votes: type === 'upVote' ? movie.votes + 1 : movie.votes - 1,
          };
        }
        return movie;
      });
    });
  };

  let filteredMovies = movies;

  if (query) {
    filteredMovies = movies.filter((movie) =>
      movie.title.toLowerCase().includes(query.toLowerCase())
    );
  }

  return (
    <html lang='en'>
      <head>
        <meta charSet='UTF-8' />
        <meta name='viewport' content='width=device-width, initial-scale=1.0' />
        <title>Cine Score</title>
        <script src='https://cdn.tailwindcss.com'></script>
      </head>
      <body>
        <div className='font-geist flex min-h-[100dvh] flex-col bg-gray-900 text-gray-200'>
          <main className='container mx-auto max-w-lg flex-grow px-4 py-8'>
            <Search onSearch={setQuery} />
            <MoviesList voteFn={voteFn} movies={filteredMovies} />
          </main>
        </div>
      </body>
    </html>
  );
}
```

</TabsContent>

<TabsContent value='search.js'>

```js
import { useTransition } from 'react';

export function Search({ onSearch }) {
  const [isSearching, startSearching] = useTransition();

  const handleChange = (e) => {
    const query = e.target.value;
    startSearching(() => {
      onSearch(query);
    });
  };

  return (
    <search className='relative mb-6 px-4'>
      <form>
        <input
          type='search'
          placeholder='Search movies...'
          className='w-full rounded-md border border-gray-700 bg-gray-800 px-8 py-2 text-gray-300 placeholder-gray-500 focus:ring-2 focus:ring-indigo-500 focus:outline-none'
          onChange={handleChange}
        />
      </form>
      {isSearching && (
        <div className='absolute top-1/2 right-6 -translate-y-1/2'>
          <div className='size-4 animate-spin rounded-full border-2 border-gray-300 border-t-gray-500' />
        </div>
      )}
    </search>
  );
}
```

</TabsContent>

<TabsContent value='movie-list.js'>

```js
import { Vote } from './vote';

export function MoviesList({ movies, voteFn }) {
  return (
    <ul
      className='max-h-[70vh] space-y-4 overflow-auto px-4'
      style={{
        scrollbarWidth: 'thin',
        scrollbarColor: '#4b5563 #1a1a1a',
      }}
    >
      {movies.length > 0 ? (
        movies.map((movie) => (
          <li
            key={movie.id}
            className='flex items-center justify-between rounded-lg bg-gray-800 p-4 shadow'
          >
            <div className='flex items-center space-x-4'>
              <Vote id={movie.id} action={voteFn} />
              <span className='text-xl font-bold'>{movie.votes}</span>
              <span className='text-gray-300'>{movie.title}</span>
            </div>
          </li>
        ))
      ) : (
        <li className='p-4 text-center text-gray-500'>No movies</li>
      )}
    </ul>
  );
}
```

</TabsContent>

<TabsContent value='vote.js'>

```js
export function Vote({ id, action }) {
  return (
    <div className='flex items-center gap-4'>
      <form action={action}>
        <input name='id' value={id} hidden readOnly />
        <input name='type' value='upVote' hidden readOnly />
        <button
          className='text-xl text-green-400 focus:outline-none disabled:opacity-50'
          type='submit'
        >
          â†‘
        </button>
      </form>
      <form action={action}>
        <input name='id' value={id} hidden readOnly />
        <input name='type' value='downVote' hidden readOnly />
        <button
          className='text-xl text-red-400 focus:outline-none disabled:opacity-50'
          type='submit'
        >
          â†“
        </button>
      </form>
    </div>
  );
}
```

</TabsContent>

<TabsContent value='server.js'>

```js
require('@babel/register')({
  ignore: [/[\\\/](dist|node_modules)[\\\/]/],
  presets: [['@babel/preset-react', { runtime: 'automatic' }]],
  plugins: ['@babel/plugin-transform-modules-commonjs'],
});

const express = require('express');
const path = require('path');
const React = require('react');
const ReactDOMServer = require('react-dom/server');
const { App } = require('./app');

const app = express();
const PORT = 1234;

app.use(express.static(path.join(__dirname, 'dist')));

function handleRequest(req, res) {
  try {
    const tree = React.createElement(App);
    const htmlStream = ReactDOMServer.renderToPipeableStream(tree, {
      bootstrapScripts: ['/client.js'],
      onShellReady: () => {
        htmlStream.pipe(res);
      },
    });
  } catch (error) {
    console.log({ error });
    res.status(500).send('Internal Server Error');
  }
}

app.get('/', handleRequest);

app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});
```

</TabsContent>

</Tabs>

Letâ€™s break this down:

- **build.js**: A standard Webpack setup, including `babel-loader`, to transpile and bundle dependencies for the browser. The entry point for compilation is client.js, with output in the `dist` folder.
- **client.js**: Hydrates the server-generated HTML using `hydrateRoot` from `react-dom/client`. The application entry point is app.js.
- **app.js**: Contains the `App` component, which builds the entire document. It uses client-side state for managing movies like searching and voting. The `Vote` component utilizes React 19's form actions for vote up-vote/down-vote functionality.
- **server.js**: A minimal HTTP server built with Express. It leverages `@babel/register` to enable on-the-fly JSX transpilation and CommonJS compatibility without a pre-compilation step. Static assets are served from the `dist` folder, and the `renderToPipeableStream` method from `react-dom/server` is used to stream the server-rendered `App` component to the client efficiently.

This approach is something weâ€™ve been doing even before React Server Components existed (like with Next.js Pages Router). Hopefully, this feels like familiar ground!. Now that we have something as a starting point, let's get into the fun part.

## Flight - React Server Component

So what exactly is RSC?

> React Server Components is a serialization and deserialization capability that supports the serialization of a superset of `structuredClone` across network boundaries. This superset includes Symbols, Promises, Iterators and Iterables, async Iterators and Iterables, React Primitives such as Function Components, `Suspense`, Client References, and Server References.

Okay, that's a big definition. Let's break it down.

Youâ€™ve probably used `JSON.stringify` and `JSON.parse` to serialize/de-serialize data for transmission over the wire. However, `JSON.stringify` has limitations it can't serialize certain types like `undefined`, `Symbol`, `Map`, or `Set`. These restrictions limit the types of data we can transmit.

This is where RSC comes in. It supports serializing all types covered by the [Structured Clone Algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm) and extends it to include additional types like Symbols, Promises, and even React-specific constructs such as Function Components, `Suspense`, Client References and Server References.

To make use of RSCs we need a RSC compatible bundler (more on why bundler is required is covered later in the post). At the time of writing this post, these are the bundlers with official implementations

1. [Parcel](https://parceljs.org/)
2. [Turbopack](https://turbo.build/pack/docs)
3. [Webpack](https://webpack.js.org/)

Parcel does a lot of heavy lifting and also hides a lot of API's to make it easy for integrating RSCs for production ready apps but we have less opportunity of learning here.

At the time of writing, turbopack is only available for Next.js development server and we cannot use turbopack outside of Next.js

Luckily we have webpack which is only a thin wrapper on top of core RSC renderer with webpack specific stuff. That's why we choose webpack as the bundler initially. Technically we can use other bundlers like esbuild with webpack implementation by monkey patching the webpack internals. But I don't want to deal with all those stuff so we are sticking with webpack and trust me it is perfectly fine for understanding core RSC implementation and all of this learnings will be the same regardless of which bundler you choose

`react-server-dom-webpack` is the official package maintained by React Core team which implements RSCs for webpack bundler. This package expose a set of utilities to leverage serialization and deserialization capabilities of RSCs. We have an option to choose between Node.js Streams and Web Stream APIs. The choice entirely depends on the use case. If your implementation needs to be runtime agnostic you can choose Web Stream APIs. Since we are just learning let's stick with Node.js Stream APIs.

Just like `react-dom/server` which provides `renderToPipeableStream` API to transform React tree into HTML, `react-server-dom-webpack/server` also provides `renderToPipeableStream` API to serialize a React tree into something called RSC Payload which can be transmitted over the wire.

As we already know RSC has the capability of serializing promises, we can make our Function Components as `async` and fetch the data required to render the UI directly inside the component itself avoiding client-server waterfall.

Enough of the theory let's convert our Plain SSR app to leverage RSC and understand it's capabilities.

Install the following dependency

```bash
npm install react-server-dom-webpack sqlite3
```

To make our lives easier, I have already seeded the data into a SQLite DB and defined some helper functions to interact with the database so that we can focus only on RSC.

<Tabs defaultValue='app.js'>

<ScrollArea className='w-full'>
  <TabsList>
    <TabsTrigger value='app.js'>app.js</TabsTrigger>
    <TabsTrigger value='server.js'>server.js</TabsTrigger>
  </TabsList>
  <ScrollBar orientation='horizontal' />
</ScrollArea>

<TabsContent value='app.js'>

```js lineNumbers addition="3,42,43,58" deletion="1,5-40,56,57"
import { useState } from 'react';

import { getMovies } from './db';
import { MoviesList } from './movie-list';
import { Search } from './search';

const initialMovies = [
  { votes: 0, id: 1, title: 'The Dark Knight' },
  { votes: 0, id: 2, title: 'Interstellar' },
  // ...............
];

export function App() {
  const [movies, setMovies] = useState(initialMovies);
  const [query, setQuery] = useState('');

  const voteFn = (formData) => {
    const id = Number(formData.get('id'));
    const type = formData.get('type');

    setMovies((prev) => {
      return prev.map((movie) => {
        if (movie.id === id) {
          return {
            ...movie,
            votes: type === 'upVote' ? movie.votes + 1 : movie.votes - 1,
          };
        }
        return movie;
      });
    });
  };

  let filteredMovies = movies;

  if (query) {
    filteredMovies = movies.filter((movie) =>
      movie.title.toLowerCase().includes(query.toLowerCase())
    );
  }

export async function App() {
  const movies = await getMovies();

  return (
    <html lang='en'>
      <head>
        <meta charSet='UTF-8' />
        <meta name='viewport' content='width=device-width, initial-scale=1.0' />
        <title>Cine Score</title>
        <script src='https://cdn.tailwindcss.com'></script>
      </head>
      <body>
        <div className='font-geist flex min-h-[100dvh] flex-col bg-gray-900 text-gray-200'>
          <main className='container mx-auto max-w-lg flex-grow px-4 py-8'>
            <Search onSearch={setQuery} />
            <MoviesList voteFn={voteFn} movies={filteredMovies} />
            <MoviesList movies={movies} />
          </main>
        </div>
      </body>
    </html>
  );
}
```

</TabsContent>

<TabsContent value='server.js'>

```js lineNumbers addition="11,28,29" deletion="10,22-27"
require('@babel/register')({
  ignore: [/[\\\/](dist|node_modules)[\\\/]/],
  presets: [['@babel/preset-react', { runtime: 'automatic' }]],
  plugins: ['@babel/plugin-transform-modules-commonjs'],
});

const express = require('express');
const path = require('path');
const React = require('react');
const ReactDOMServer = require('react-dom/server');
const ReactServerDOMWebpackServer = require('react-server-dom-webpack/server');
const { App } = require('./app');

const app = express();
const PORT = 1234;

app.use(express.static(path.join(__dirname, 'dist')));

function handleRequest(req, res) {
  try {
    const tree = React.createElement(App);
    const htmlStream = ReactDOMServer.renderToPipeableStream(tree, {
      bootstrapScripts: ['/client.js'],
      onShellReady: () => {
        htmlStream.pipe(res);
      },
    });
    const rscStream = ReactServerDOMWebpackServer.renderToPipeableStream(tree);
    rscStream.pipe(res);
  } catch (error) {
    console.log({ error });
    res.status(500).send('Internal Server Error');
  }
}

app.get('/', handleRequest);

app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});
```

</TabsContent>

</Tabs>

Let's go over the diff and understand the changes.

Firstly, we can directly fetch the movies list inside the `App` by making the `App` component `async` thanks to RSC capability of serializing Promises. I have intentionally removed the `Search` component and vote function. Weâ€™ll get to those later in the post, but for now, bear with me.

In the server.js, we have used `renderToPipeableStream` from `react-server-dom-webpack` instead of `react-dom/server`. From what we understood earlier, when we run our server, everything should work right?

Sadly, it isnâ€™t that straightforward. Youâ€™ll encounter an error stating:

> The React Server Writer cannot be used outside a react-server environment. You must configure Node.js using the `--conditions react-server` flag

When I first encountered this error, I searched through the internet and github issues but found nothing because nothing is documented yet. I taught that this stuff isn't meant for me. When I revisited it later, I realized the error itself gives you the solution, and I failed to understand it due to skill issues.

### The react-server Conditional Export

The solution is that you must configure Node.js to use the `--conditions react-server` flag. Iâ€™m sure many of you, like me, might not have heard of this before. So, I started exploring the Node.js documentation and found that we should use the `react-server` conditional export to utilize RSC. The `--conditions` flag is a CLI option in Node.js where we can pass `react-server` as the value for custom conditional exports resolution.

Discussing conditional exports in detail is beyond the scope of this article, but you can learn more about them in the Node.js documentation linked [here](https://nodejs.org/api/packages.html#conditional-exports).

> Why do we need to do this? Honestly, I donâ€™t have a perfect answer. From what I understand, it acts as a guard clause to prevent Reactâ€™s server APIs from leaking into the client environment. Again, this might not be entirely correct. If you have a better explanation, please leave a comment belowâ€”it will help me and other readers gain a clearer understanding.

To fix the issue, letâ€™s update the `package.json` file by adding the required CLI flag:

```json lineNumbers filename="package.json" addition="6,16,17" deletion="5"
{
  "name": "cine-score",
  "scripts": {
    "build": "node build.js",
    "server": "node server.js",
    "server": "node --conditions react-server server.js",
    "start": "npm run build && npm run server"
  },
  "dependencies": {
    "@babel/core": "^7.26.0",
    "@babel/plugin-transform-modules-commonjs": "^7.26.3",
    "@babel/preset-react": "^7.26.3",
    "@babel/register": "^7.25.9",
    "babel-loader": "^9.2.1",
    "express": "^4.21.2",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-server-dom-webpack": "^19.0.0",
    "sqlite3": "^5.1.7",
    "webpack": "^5.97.1"
  }
}
```

If we run the server now, it will start successfully. However, when you visit the dev server in your browser, you will see a bunch of what appears to be garbage text instead of the beautiful movie listing UI we had earlier.

Is this text really garbage? How do we get back our beautiful UI? Letâ€™s address these questions step by step.

### RSC Payload

Iâ€™ve often seen tutorials and articles describe React Server Components (RSCs) as React components that only run on the server, return HTML to the browser, and never run on the client. Honestly, I believed the same when I first came across RSCs, but sadly, that is not true. This might be one of the main reasons for the confusion surrounding RSCs. The idea that RSCs run only on the server and never on the client is **partially true**, but the claim that RSCs return HTML is completely false.

By now, we already know that RSC is a serialization/deserialization capability. The "garbage text" is nothing but the serialized version of the React tree that we passed as input to `renderToPipeableStream`. Hereâ€™s a stripped-down version of the RSC payload for our `App` component:

<RSCPayload />

Letâ€™s try to understand this output:

The first line represents our `App` component, prefixed with `1`. If you observe the second line, there is some mapping occurring between `0` and `1`. The line with the prefix `0` is the JSX returned from the `App` component. This indicates that the function component is mapped to its returned JSX. The same pattern is followed for the entire React tree, where each component is mapped to its returned JSX.

One interesting detail to observe is that since we didnâ€™t pass any value to the `action` prop of the `MovieList` component, its value is `undefined`. As discussed earlier, the value `undefined` gets serialized to `"$undefined"`. If it were a normal `JSON.stringify`, the prop itself would have been omitted.

Now that we understand what this text is, the next question is: **How do we get back the UI?**

### Apply Fizz on Flight

Just like how we have APIs to serialize the React tree into an RSC payload, we also have APIs to deserialize the RSC payload back into a React tree, provided by `react-server-dom-webpack/client`. Since we already have the capability of server-side rendering (SSR) the React treeâ€”i.e., converting the React element tree into HTMLâ€”we can retrieve the React tree from the RSC payload and convert it into HTML using the APIs provided by `react-dom/server`. Let's dive into the code for better understanding:

```js lineNumbers filename="server.js" addition="11,12,21,24-27,29" deletion="20,28"
require('@babel/register')({
  ignore: [/[\\\/](dist|node_modules)[\\\/]/],
  presets: [['@babel/preset-react', { runtime: 'automatic' }]],
  plugins: ['@babel/plugin-transform-modules-commonjs'],
});

const express = require('express');
const path = require('path');
const React = require('react');
const ReactServerDOMWebpackServer = require('react-server-dom-webpack/server');
const ReactServerDOMWebpackClient = require('react-server-dom-webpack/client');
const ReactDOMServer = require('react-dom/server');
const { App } = require('./app');

const app = express();
const PORT = 1234;

app.use(express.static(path.join(__dirname, 'dist')));

function handleRequest(req, res) {
async function handleRequest(req, res) {
  try {
    const tree = React.createElement(App);
    const rscStream = ReactServerDOMWebpackServer.renderToPipeableStream(tree);
    const renderedReactTree =
      await ReactServerDOMWebpackClient.createFromNodeStream(rscStream);
    const htmlStream = ReactDOMServer.renderToPipeableStream(renderedReactTree);
    rscStream.pipe(res);
    htmlStream.pipe(res);
  } catch (error) {
    console.log({ error });
    res.status(500).send('Internal Server Error');
  }
}

app.get('/', handleRequest);

app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});
```

We use the `createFromNodeStream` API from `react-server-dom-webpack/client` to deserialize the RSC payload back into a React tree. Then, we pass this tree to the `renderToPipeableStream` API from `react-dom/server` to convert the React tree into an HTML stream and send it to the browser.

Ideally, when we run the server now, we should see our beautiful Movie list UI.

However, weâ€™ll encounter another error:

> `react-dom/server` is not supported in React Server Components

This time, it was relatively easy to figure out the cause of the error. Since we are using the `react-server` export condition to enable RSCs, the `react-dom/server` package cannot be imported under the `react-server` condition. Why doesnâ€™t it work under the `react-server` export condition? As explained [earlier](#the-react-server-conditional-export), this is to prevent leaking React Server APIs into the client environment. Even though we are using the `react-dom/server` subpath, it is still a client-side library intended for DOM-related operations.

The difficult part was finding a working solution for this error. At one point, I completely gave up on SSR and switched entirely to CSR. To my surprise, the CSR approach worked as expected, which motivated me to revisit the SSR implementation. After a month of struggling, I found two ways to address this:

1. Two separate servers: one for SSR and one for RSC, where the SSR server proxies incoming requests from the browser to the RSC server, retrieves the RSC payload, and converts it into HTML.
2. A single server with worker threads for SSR.

The first approach is relatively simple to set up and get working. However, weâ€™ll choose the second approach because:

> I donâ€™t want peace; I want problems ALWAYS!!! ðŸ˜‚
