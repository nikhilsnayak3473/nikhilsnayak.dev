import cineScoreThumbnail from './cine-score-thumbnail.png';
import { RSCPayload } from './rsc-payload.tsx';

## Introduction

Yes, you might have already guessed it from the title, we are finally diving deep into [**React Server Components**](https://react.dev/reference/rsc/server-components). Since React 19 is finally stable no more noise about RSCs being experimental, canary, or any of that.

We'll explore React's full-stack architecture by building a simple full-stack app called **Cine Score**. In this app, users can browse a list of movies, up-vote or down-vote a movie, and search through the collection. Here's a sneak peek at what we'll create:

<Image src={cineScoreThumbnail} alt='Cine Score thumbnail' />

Not excited yet? ðŸ¤” What if I told you we'd build this app _without_ using any frameworks? Sounds exciting, right? ðŸŽ‰ Get ready, because we're going to rely solely on the tools provided by React and a few helper libraries.

By the end of this post, I aim to give you a _solid_ understanding of how RSC frameworks work under the hood. This way, you'll be able to use these frameworks wisely instead of fighting them.

> **Disclaimer:** All the code and implementation details discussed in this post are for educational purposes only and are not intended for production use. If you are already familiar working with RSCs in frameworks like Next.js it would help a lot understanding this deep dive

## Project Setup

We'll start with a clean slate and build everything step by step. For simplicity, we won't be using TypeScript. If you'd like to follow along, make sure you have the latest **LTS** version of Node.js installed.

Let's create a new Node.js project:

```bash
mkdir cine-score && cd cine-score && npm init -y
```

Install the following dependencies:

```bash
npm install express react react-dom webpack @babel/core @babel/register @babel/preset-react @babel/transform-modules-commonjs babel-loader
```

<CollapsibleContent summary="Overview of each dependency's role:">

- **webpack**: A bundler used to compile JavaScript for the browser.

- **@babel/core**: The core Babel library used to transform JSX into browser-compatible JavaScript.

- **@babel/register**: A runtime helper for Babel that enables on-the-fly transpilation of ES6+ and JSX in Node.js without pre-compilation.

- **@babel/preset-react**: A Babel preset for transpiling JSX and React-specific syntax into JavaScript.

- **@babel/transform-modules-commonjs**: A Babel plugin that transforms ES module syntax (`import`/`export`) into CommonJS (`require`/`module.exports`) for Node.js compatibility.

- **babel-loader**: A Webpack loader that integrates Babel to transpile JavaScript files during the build process.

</CollapsibleContent>

## Fizz - Traditional React SSR

Let's bootstrap the app in the traditional SSR way, as we've been doing since the early days of Next.js.

Here's the folder structure and the files in the SSR version:

```
cine-score/
â”œâ”€â”€ package.json
â”œâ”€â”€ build.js       # Build script
â”œâ”€â”€ client.js      # Client-side logic
â”œâ”€â”€ app.js         # Main application entry point
â”œâ”€â”€ search.js      # Component: search functionality
â”œâ”€â”€ movie-list.js  # Component: movie listing
â”œâ”€â”€ vote.js        # Component: voting functionality
â””â”€â”€ server.js      # Server-side logic
```

<Tabs defaultValue='package.json'>

<ScrollArea className='w-full'>
  <TabsList>
    <TabsTrigger value='package.json'>package.json</TabsTrigger>
    <TabsTrigger value='build.js'>build.js</TabsTrigger>
    <TabsTrigger value='client.js'>client.js</TabsTrigger>
    <TabsTrigger value='app.js'>app.js</TabsTrigger>
    <TabsTrigger value='search.js'>search.js</TabsTrigger>
    <TabsTrigger value='movie-list.js'>movie-list.js</TabsTrigger>
    <TabsTrigger value='vote.js'>vote.js</TabsTrigger>
    <TabsTrigger value='server.js'>server.js</TabsTrigger>
  </TabsList>
  <ScrollBar orientation='horizontal' />
</ScrollArea>

<TabsContent value='package.json'>

```json
{
  "name": "cine-score",
  "scripts": {
    "build": "node build.js",
    "server": "node server.js",
    "start": "npm run build && npm run server"
  },
  "dependencies": {
    "@babel/core": "^7.26.0",
    "@babel/plugin-transform-modules-commonjs": "^7.26.3",
    "@babel/preset-react": "^7.26.3",
    "@babel/register": "^7.25.9",
    "babel-loader": "^9.2.1",
    "express": "^4.21.2",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "webpack": "^5.97.1"
  }
}
```

</TabsContent>

<TabsContent value='build.js'>

```js
const path = require('path');
const webpack = require('webpack');

const builder = webpack({
  mode: process.env.NODE_ENV ?? 'development',
  entry: path.resolve(__dirname, './client.js'),
  output: {
    path: path.resolve(__dirname, './dist'),
    filename: 'client.js',
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: [
              [
                '@babel/preset-react',
                {
                  runtime: 'automatic',
                },
              ],
            ],
          },
        },
      },
    ],
  },
});

builder.run((err) => {
  if (err) console.error('Webpack Build Failed', err);
});
```

</TabsContent>

<TabsContent value='client.js'>

```js
import ReactDOMClient from 'react-dom/client';

import { App } from './app';

ReactDOMClient.hydrateRoot(document, <App />);
```

</TabsContent>

<TabsContent value='app.js'>

```js
import { useState } from 'react';

import { MoviesList } from './movie-list';
import { Search } from './search';

const initialMovies = [
  { votes: 0, id: 1, title: 'The Dark Knight' },
  { votes: 0, id: 2, title: 'Interstellar' },
  // ...............
];

export function App() {
  const [movies, setMovies] = useState(initialMovies);
  const [query, setQuery] = useState('');

  const voteFn = (formData) => {
    const id = Number(formData.get('id'));
    const type = formData.get('type');

    setMovies((prev) => {
      return prev.map((movie) => {
        if (movie.id === id) {
          return {
            ...movie,
            votes: type === 'upVote' ? movie.votes + 1 : movie.votes - 1,
          };
        }
        return movie;
      });
    });
  };

  let filteredMovies = movies;

  if (query) {
    filteredMovies = movies.filter((movie) =>
      movie.title.toLowerCase().includes(query.toLowerCase())
    );
  }

  return (
    <html lang='en'>
      <head>
        <meta charSet='UTF-8' />
        <meta name='viewport' content='width=device-width, initial-scale=1.0' />
        <title>Cine Score</title>
        <script src='https://cdn.tailwindcss.com'></script>
      </head>
      <body>
        <div className='flex min-h-[100dvh] flex-col bg-gray-900 text-gray-200'>
          <main className='container mx-auto max-w-lg flex-grow px-4 py-8'>
            <Search onSearch={setQuery} />
            <MoviesList voteFn={voteFn} movies={filteredMovies} />
          </main>
        </div>
      </body>
    </html>
  );
}
```

</TabsContent>

<TabsContent value='search.js'>

```js
import { useTransition } from 'react';

export function Search({ onSearch }) {
  const [isSearching, startSearching] = useTransition();

  const handleChange = (e) => {
    const query = e.target.value;
    startSearching(() => {
      onSearch(query);
    });
  };

  return (
    <search className='relative mb-6 px-4'>
      <form>
        <input
          type='search'
          placeholder='Search movies...'
          className='w-full rounded-md border border-gray-700 bg-gray-800 px-8 py-2 text-gray-300 placeholder-gray-500 focus:ring-2 focus:ring-indigo-500 focus:outline-none'
          onChange={handleChange}
        />
      </form>
      {isSearching && (
        <div className='absolute top-1/2 right-6 -translate-y-1/2'>
          <div className='size-4 animate-spin rounded-full border-2 border-gray-300 border-t-gray-500' />
        </div>
      )}
    </search>
  );
}
```

</TabsContent>

<TabsContent value='movie-list.js'>

```js
import { Vote } from './vote';

export function MoviesList({ movies, voteFn }) {
  return (
    <ul
      className='max-h-[70vh] space-y-4 overflow-auto px-4'
      style={{
        scrollbarWidth: 'thin',
        scrollbarColor: '#4b5563 #1a1a1a',
      }}
    >
      {movies.length > 0 ? (
        movies.map((movie) => (
          <li
            key={movie.id}
            className='flex items-center justify-between rounded-lg bg-gray-800 p-4 shadow'
          >
            <div className='flex items-center space-x-4'>
              <Vote id={movie.id} action={voteFn} />
              <span className='text-xl font-bold'>{movie.votes}</span>
              <span className='text-gray-300'>{movie.title}</span>
            </div>
          </li>
        ))
      ) : (
        <li className='p-4 text-center text-gray-500'>No movies</li>
      )}
    </ul>
  );
}
```

</TabsContent>

<TabsContent value='vote.js'>

```js
export function Vote({ id, action }) {
  return (
    <div className='flex items-center gap-4'>
      <form action={action}>
        <input name='id' value={id} hidden readOnly />
        <input name='type' value='upVote' hidden readOnly />
        <button
          className='text-xl text-green-400 focus:outline-none disabled:opacity-50'
          type='submit'
        >
          â†‘
        </button>
      </form>
      <form action={action}>
        <input name='id' value={id} hidden readOnly />
        <input name='type' value='downVote' hidden readOnly />
        <button
          className='text-xl text-red-400 focus:outline-none disabled:opacity-50'
          type='submit'
        >
          â†“
        </button>
      </form>
    </div>
  );
}
```

</TabsContent>

<TabsContent value='server.js'>

```js
require('@babel/register')({
  ignore: [/[\\\/](dist|node_modules)[\\\/]/],
  presets: [['@babel/preset-react', { runtime: 'automatic' }]],
  plugins: ['@babel/plugin-transform-modules-commonjs'],
});

const express = require('express');
const path = require('path');
const React = require('react');
const ReactDOMServer = require('react-dom/server');
const { App } = require('./app');

const app = express();
const PORT = 1234;

app.use(express.static(path.join(__dirname, 'dist')));

function handleRequest(req, res) {
  try {
    const tree = React.createElement(App);
    const htmlStream = ReactDOMServer.renderToPipeableStream(tree, {
      bootstrapScripts: ['/client.js'],
      onShellReady: () => {
        htmlStream.pipe(res);
      },
    });
  } catch (error) {
    console.log({ error });
    res.status(500).send('Internal Server Error');
  }
}

app.get('/', handleRequest);

app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});
```

</TabsContent>

</Tabs>

Let's break this down:

- **build.js**: A standard Webpack setup, including `babel-loader`, to transpile and bundle dependencies for the browser. The entry point for compilation is client.js, with output in the `dist` folder.
- **client.js**: Hydrates the server-generated HTML using `hydrateRoot` from `react-dom/client`. The application entry point is app.js.
- **app.js**: Contains the `App` component, which builds the entire document. It uses client-side state for managing movies like searching and voting. The `Vote` component utilizes React 19's form actions for vote up-vote/down-vote functionality.
- **server.js**: A minimal HTTP server built with Express. It leverages `@babel/register` to enable on-the-fly JSX transpilation and CommonJS compatibility without a pre-compilation step. Static assets are served from the `dist` folder, and the `renderToPipeableStream` method from `react-dom/server` is used to stream the server-rendered `App` component to the client efficiently.

This approach is something we've been doing even before React Server Components existed (like with Next.js Pages Router). Hopefully, this feels like familiar ground!. Now that we have something as a starting point, let's get into the fun part.

## Flight - React Server Component

So what exactly is RSC?

> React Server Components is a serialization and deserialization capability that supports the serialization of a superset of `structuredClone` across network boundaries. This superset includes Symbols, Promises, Iterators and Iterables, async Iterators and Iterables, React Primitives such as Function Components, `Suspense`, Client References, and Server References.

Okay, that's a big definition. Let's break it down.

You've probably used `JSON.stringify` and `JSON.parse` to serialize/de-serialize data for transmission over the wire. However, `JSON.stringify` has limitations it can't serialize certain types like `undefined`, `Symbol`, `Map`, or `Set`. These restrictions limit the types of data we can transmit.

This is where RSC comes in. It supports serializing all types covered by the [Structured Clone Algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm) and extends it to include additional types like Symbols, Promises, and even React-specific constructs such as Function Components, `Suspense`, Client References and Server References.

To make use of RSCs we need a RSC compatible bundler (more on why bundler is required is covered later in the post). At the time of writing this post, these are the bundlers with official implementations

1. [Parcel](https://parceljs.org/)
2. [Turbopack](https://turbo.build/pack/docs)
3. [Webpack](https://webpack.js.org/)

Parcel does a lot of heavy lifting and also hides a lot of API's to make it easy for integrating RSCs for production ready apps but we have less opportunity of learning here.

At the time of writing, turbopack is only available for Next.js development server and we cannot use turbopack outside of Next.js

Luckily we have webpack which is only a thin wrapper on top of core RSC renderer with webpack specific stuff. That's why we choose webpack as the bundler initially. Technically we can use other bundlers like esbuild with webpack implementation by monkey patching the webpack internals. But I don't want to deal with all those stuff so we are sticking with webpack and trust me it is perfectly fine for understanding core RSC implementation and all of this learnings will be the same regardless of which bundler you choose

`react-server-dom-webpack` is the official package maintained by React Core team which implements RSCs for webpack bundler. This package expose a set of utilities to leverage serialization and deserialization capabilities of RSCs. We have an option to choose between Node.js Streams and Web Stream APIs. The choice entirely depends on the use case. If your implementation needs to be runtime agnostic you can choose Web Stream APIs. Since we are just learning let's stick with Node.js Stream APIs.

Just like `react-dom/server` which provides `renderToPipeableStream` API to transform React tree into HTML, `react-server-dom-webpack/server` also provides `renderToPipeableStream` API to serialize a React tree into something called RSC Payload which can be transmitted over the wire.

As we already know RSC has the capability of serializing promises, we can make our Function Components as `async` and fetch the data required to render the UI directly inside the component itself avoiding client-server waterfall.

Enough of the theory let's convert our Plain SSR app to leverage RSC and understand it's capabilities.

Install the following dependency

```bash
npm install react-server-dom-webpack sqlite3
```

To make our lives easier, I have already seeded the data into a SQLite DB and defined some helper functions to interact with the database so that we can focus only on RSC.

<Tabs defaultValue='app.js'>

<ScrollArea className='w-full'>
  <TabsList>
    <TabsTrigger value='app.js'>app.js</TabsTrigger>
    <TabsTrigger value='server.js'>server.js</TabsTrigger>
  </TabsList>
  <ScrollBar orientation='horizontal' />
</ScrollArea>

<TabsContent value='app.js'>

```js lineNumbers addition="3,42,43,58" deletion="1,5-40,56,57"
import { useState } from 'react';

import { getMovies } from './db';
import { MoviesList } from './movie-list';
import { Search } from './search';

const initialMovies = [
  { votes: 0, id: 1, title: 'The Dark Knight' },
  { votes: 0, id: 2, title: 'Interstellar' },
  // ...............
];

export function App() {
  const [movies, setMovies] = useState(initialMovies);
  const [query, setQuery] = useState('');

  const voteFn = (formData) => {
    const id = Number(formData.get('id'));
    const type = formData.get('type');

    setMovies((prev) => {
      return prev.map((movie) => {
        if (movie.id === id) {
          return {
            ...movie,
            votes: type === 'upVote' ? movie.votes + 1 : movie.votes - 1,
          };
        }
        return movie;
      });
    });
  };

  let filteredMovies = movies;

  if (query) {
    filteredMovies = movies.filter((movie) =>
      movie.title.toLowerCase().includes(query.toLowerCase())
    );
  }

export async function App() {
  const movies = await getMovies();

  return (
    <html lang='en'>
      <head>
        <meta charSet='UTF-8' />
        <meta name='viewport' content='width=device-width, initial-scale=1.0' />
        <title>Cine Score</title>
        <script src='https://cdn.tailwindcss.com'></script>
      </head>
      <body>
        <div className='flex min-h-[100dvh] flex-col bg-gray-900 text-gray-200'>
          <main className='container mx-auto max-w-lg flex-grow px-4 py-8'>
            <Search onSearch={setQuery} />
            <MoviesList voteFn={voteFn} movies={filteredMovies} />
            <MoviesList movies={movies} />
          </main>
        </div>
      </body>
    </html>
  );
}
```

</TabsContent>

<TabsContent value='server.js'>

```js lineNumbers addition="11,28,29" deletion="10,22-27"
require('@babel/register')({
  ignore: [/[\\\/](dist|node_modules)[\\\/]/],
  presets: [['@babel/preset-react', { runtime: 'automatic' }]],
  plugins: ['@babel/plugin-transform-modules-commonjs'],
});

const express = require('express');
const path = require('path');
const React = require('react');
const ReactDOMServer = require('react-dom/server');
const ReactServerDOMWebpackServer = require('react-server-dom-webpack/server');
const { App } = require('./app');

const app = express();
const PORT = 1234;

app.use(express.static(path.join(__dirname, 'dist')));

function handleRequest(req, res) {
  try {
    const tree = React.createElement(App);
    const htmlStream = ReactDOMServer.renderToPipeableStream(tree, {
      bootstrapScripts: ['/client.js'],
      onShellReady: () => {
        htmlStream.pipe(res);
      },
    });
    const rscStream = ReactServerDOMWebpackServer.renderToPipeableStream(tree);
    rscStream.pipe(res);
  } catch (error) {
    console.log({ error });
    res.status(500).send('Internal Server Error');
  }
}

app.get('/', handleRequest);

app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});
```

</TabsContent>

</Tabs>

Let's go over the diff and understand the changes.

Firstly, we can directly fetch the movies list inside the `App` by making the `App` component `async` thanks to RSC capability of serializing Promises. I have intentionally removed the `Search` component and vote function. We'll get to those later in the post, but for now, bear with me.

In the server.js, we have used `renderToPipeableStream` from `react-server-dom-webpack` instead of `react-dom/server`. From what we understood earlier, when we run our server, everything should work right?

Sadly, it isn't that straightforward. You'll encounter an error stating:

> The React Server Writer cannot be used outside a react-server environment. You must configure Node.js using the `--conditions react-server` flag

When I first encountered this error, I searched through the internet and github issues but found nothing because nothing is documented yet. I taught that this stuff isn't meant for me. When I revisited it later, I realized the error itself gives you the solution, and I failed to understand it due to skill issues.

### The react-server Conditional Export

The solution is that you must configure Node.js to use the `--conditions react-server` flag. I'm sure many of you, like me, might not have heard of this before. So, I started exploring the Node.js documentation and found that we should use the `react-server` conditional export to utilize RSC. The `--conditions` flag is a CLI option in Node.js where we can pass `react-server` as the value for custom conditional exports resolution.

Discussing conditional exports in detail is beyond the scope of this article, but you can learn more about them in the Node.js documentation linked [here](https://nodejs.org/api/packages.html#conditional-exports).

> Why do we need to do this? Honestly, I don't have a perfect answer. From what I understand, it acts as a guard clause to prevent React's server APIs from leaking into the client environment. Again, this might not be entirely correct. If you have a better explanation, please leave a comment belowâ€”it will help me and other readers gain a clearer understanding.

To fix the issue, let's update the `package.json` file by adding the required CLI flag:

```json lineNumbers filename="package.json" addition="6,16,17" deletion="5"
{
  "name": "cine-score",
  "scripts": {
    "build": "node build.js",
    "server": "node server.js",
    "server": "node --conditions react-server server.js",
    "start": "npm run build && npm run server"
  },
  "dependencies": {
    "@babel/core": "^7.26.0",
    "@babel/plugin-transform-modules-commonjs": "^7.26.3",
    "@babel/preset-react": "^7.26.3",
    "@babel/register": "^7.25.9",
    "babel-loader": "^9.2.1",
    "express": "^4.21.2",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-server-dom-webpack": "^19.0.0",
    "sqlite3": "^5.1.7",
    "webpack": "^5.97.1"
  }
}
```

If we run the server now, it will start successfully. However, when you visit the dev server in your browser, you will see a bunch of what appears to be garbage text instead of the beautiful movie listing UI we had earlier.

Is this text really garbage? How do we get back our beautiful UI? Let's address these questions step by step.

### RSC Payload

I've often seen tutorials and articles describe React Server Components (RSCs) as React components that only run on the server, return HTML to the browser, and never run on the client. Honestly, I believed the same when I first came across RSCs, but sadly, that is not true. This might be one of the main reasons for the confusion surrounding RSCs. The idea that RSCs run only on the server and never on the client is **partially true**, but the claim that RSCs return HTML is completely false.

By now, we already know that RSC is a serialization/deserialization capability. The "garbage text" is nothing but the serialized version of the React tree that we passed as input to `renderToPipeableStream`. Here's a stripped-down version of the RSC payload for our `App` component:

<RSCPayload />

Let's try to understand this output:

The first line represents our `App` component, prefixed with `1`. If you observe the second line, there is some mapping occurring between `0` and `1`. The line with the prefix `0` is the JSX returned from the `App` component. This indicates that the function component is mapped to its returned JSX. The same pattern is followed for the entire React tree, where each component is mapped to its returned JSX.

One interesting detail to observe is that since we didn't pass any value to the `action` prop of the `MovieList` component, its value is `undefined`. As discussed earlier, the value `undefined` gets serialized to `"$undefined"`. If it were a normal `JSON.stringify`, the prop itself would have been omitted.

Now that we understand what this text is, the next question is: **How do we get back the UI?**

### Apply Fizz on Flight

Just like how we have APIs to serialize the React tree into an RSC payload, we also have APIs to deserialize the RSC payload back into a React tree, provided by `react-server-dom-webpack/client`. Since we already have the capability of server-side rendering (SSR) the React treeâ€”i.e., converting the React element tree into HTMLâ€”we can retrieve the React tree from the RSC payload and convert it into HTML using the APIs provided by `react-dom/server`. Let's dive into the code for better understanding:

{/* prettier-ignore */}
```js lineNumbers filename="server.js" addition="11,12,21,25-27,29-33" deletion="20,28"
require('@babel/register')({
  ignore: [/[\\\/](dist|node_modules)[\\\/]/],
  presets: [['@babel/preset-react', { runtime: 'automatic' }]],
  plugins: ['@babel/plugin-transform-modules-commonjs'],
});

const express = require('express');
const path = require('path');
const React = require('react');
const ReactServerDOMWebpackServer = require('react-server-dom-webpack/server');
const ReactServerDOMWebpackClient = require('react-server-dom-webpack/client');
const ReactDOMServer = require('react-dom/server');
const { App } = require('./app');

const app = express();
const PORT = 1234;

app.use(express.static(path.join(__dirname, 'dist')));

function handleRequest(req, res) {
async function handleRequest(req, res) {
  try {
    const tree = React.createElement(App);
    const rscStream = ReactServerDOMWebpackServer.renderToPipeableStream(tree);
    const renderedReactTree = await ReactServerDOMWebpackClient.createFromNodeStream(rscStream, {
      moduleMap: {},
    });
    rscStream.pipe(res);
    const htmlStream = ReactDOMServer.renderToPipeableStream(renderedReactTree, {
      onShellReady: () => {
        htmlStream.pipe(res);
      },
    });
  } catch (error) {
    console.log({ error });
    res.status(500).send('Internal Server Error');
  }
}

app.get('/', handleRequest);

app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});
```

We use the `createFromNodeStream` API from `react-server-dom-webpack/client` to deserialize the RSC payload back into a React tree (Ignore the 2nd argument passed for now. We will discuss it in detail later). Then, we pass this tree to the `renderToPipeableStream` API from `react-dom/server` to convert the React tree into an HTML stream and send it to the browser.

Ideally, when we run the server now, we should see our beautiful Movie list UI.

However, we'll encounter another error:

> `react-dom/server` is not supported in React Server Components

This time, it was relatively easy to figure out the cause of the error. Since we are using the `react-server` export condition to enable RSCs, the `react-dom/server` package cannot be imported under the `react-server` condition. Why doesn't it work under the `react-server` export condition? As explained [earlier](#the-react-server-conditional-export), this is to prevent leaking React Server APIs into the client environment. Even though we are using the `react-dom/server` subpath, it is still a client-side library intended for DOM-related operations.

The difficult part was finding a working solution for this error. At one point, I completely gave up on SSR and switched entirely to CSR. To my surprise, the CSR approach worked as expected, which motivated me to revisit the SSR implementation. After a month of struggling, I found two ways to address this:

1. Two separate servers: one for SSR and one for RSC, where the SSR server proxies incoming requests from the browser to the RSC server, retrieves the RSC payload, and converts it into HTML.
2. A single server with worker threads for SSR.

The first approach is relatively simple to set up and get working. However, we'll choose the second approach because:

> I don't want peace; I want problems ALWAYS!!! ðŸ˜‚

#### Fizz Worker

Let's implement the SSR logic in a separate file called `fizz-worker.js`. This worker is responsible for taking the RSC stream, converting it to an HTML stream, and sending the HTML stream back to the main thread.

<Tabs defaultValue='fizz-worker.js'>

<ScrollArea className='w-full'>
  <TabsList>
    <TabsTrigger value='fizz-worker.js'>fizz-worker.js</TabsTrigger>
    <TabsTrigger value='server.js'>server.js</TabsTrigger>
  </TabsList>
  <ScrollBar orientation='horizontal' />
</ScrollArea>

<TabsContent value='fizz-worker.js'>

{/* prettier-ignore */}
```js
const { parentPort } = require('worker_threads');
const { Writable, PassThrough } = require('stream');
const ReactServerDOMWebpackClient = require('react-server-dom-webpack/client');
const ReactDOMServer = require('react-dom/server');

parentPort.on('message', async (request) => {
  const htmlConsumerRSCStream = new PassThrough();

  request.port.on('message', (message) => {
    if (message.type === 'data') {
      htmlConsumerRSCStream.write(message.data);
    } else if (message.type === 'end') {
      htmlConsumerRSCStream.end();
    }
  });

  const writableStream = new Writable({
    write(chunk, encoding, callback) {
      request.port.postMessage({
        type: 'data',
        data: chunk,
      });
      callback();
    },
    final(callback) {
      request.port.postMessage({ type: 'end' });
      callback();
    },
  });

  const tree = await ReactServerDOMWebpackClient.createFromNodeStream(htmlConsumerRSCStream, {
    moduleMap: {},
  });

  const htmlStream = ReactDOMServer.renderToPipeableStream(tree, {
    onShellReady: () => {
      htmlStream.pipe(writableStream);
    },
  });
});
```

</TabsContent>

<TabsContent value='server.js'>

{/* prettier-ignore */}
```js lineNumbers addition="13,14,20-22,38-71" deletion="11,12,30-37"
require('@babel/register')({
  ignore: [/[\\\/](dist|node_modules)[\\\/]/],
  presets: [['@babel/preset-react', { runtime: 'automatic' }]],
  plugins: ['@babel/plugin-transform-modules-commonjs'],
});

const express = require('express');
const path = require('path');
const React = require('react');
const ReactServerDOMWebpackServer = require('react-server-dom-webpack/server');
const ReactServerDOMWebpackClient = require('react-server-dom-webpack/client');
const ReactDOMServer = require('react-dom/server');
const { Worker, MessageChannel } = require('worker_threads');
const { PassThrough } = require('stream');
const { App } = require('./app');

const app = express();
const PORT = 1234;

const fizzWorker = new Worker(path.resolve(__dirname, './fizz-worker.js'), {
  execArgv: ['--conditions', 'default'],
});

app.use(express.static(path.join(__dirname, 'dist')));

async function handleRequest(req, res) {
  try {
    const tree = React.createElement(App);
    const rscStream = ReactServerDOMWebpackServer.renderToPipeableStream(tree);
    const renderedReactTree = await ReactServerDOMWebpackClient.createFromNodeStream(rscStream, {
      moduleMap: {},
    });
    const htmlStream = ReactDOMServer.renderToPipeableStream(renderedReactTree, {
      onShellReady: () => {
        htmlStream.pipe(res);
      },
    });

    res.setHeader('Content-Type', 'text/html');

    const { port1, port2 } = new MessageChannel();

    const request = {
      port: port2,
    };

    fizzWorker.postMessage(request, [port2]);

    const passThroughRSCStream = new PassThrough();
    rscStream.pipe(passThroughRSCStream);

    passThroughRSCStream.on('data', (data) => {
      port1.postMessage({
        type: 'data',
        data,
      });
    });

    passThroughRSCStream.on('end', () => {
      port1.postMessage({
        type: 'end',
      });
    });

    port1.on('message', (message) => {
      if (message.type === 'data') {
        res.write(message.data);
      } else if (message.type === 'end') {
        res.end();
      }
    });
  } catch (error) {
    console.log({ error });
    res.status(500).send('Internal Server Error');
  }
}

app.get('/', handleRequest);

app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});
```

</TabsContent>

</Tabs>

I get it. The code looks more complicated than before, but trust me, it's pretty straightforward. Let's break it down.

We use [`parentPort`](https://nodejs.org/api/worker_threads.html#workerparentport) from `worker_threads` to listen to incoming messages from the main thread. In the callback of the `message` event, we receive the data from the main thread. This data contains a message port transferred to the worker. A message port is one end of an asynchronous two-way communication channel that allows us to receive the RSC stream chunk by chunk and send back the HTML stream chunk by chunk.

Since we can't pass the RSC stream directly to the `createFromNodeStream` API, we use a [`PassThrough`](https://nodejs.org/api/stream.html#class-streampassthrough). This `PassThrough` acts as a proxy that takes in the RSC stream chunk by chunk and passes it as a [`Readable`](https://nodejs.org/api/stream.html#class-streamreadable) Node.js stream.

We add a `message` event listener to the port received from the main thread. In the callback, we write the data to the `PassThrough` stream or close it based on the message type.

Once we get the React tree from the RSC stream, we pass it to `renderToPipeableStream` from `react-dom/server` to generate the HTML stream.

Since we can't directly return the HTML stream to the main thread, we create a [`Writable`](https://nodejs.org/api/stream.html#class-streamwritable) and pipe the HTML stream into it. Inside the `write` method, we send the HTML chunk by chunk to the main thread using `port.postMessage`.

In the main thread, we create a new [`Worker`](https://nodejs.org/api/worker_threads.html#class-worker) called `fizzWorker` with CLI args as `--conditions default` which is what enables use to use Reacts Client APIs. we use a [`MessageChannel`](https://nodejs.org/api/worker_threads.html#class-messagechannel), which provides `port1` and `port2`. We transfer `port2` to the worker thread using `worker.postMessage`. Since we can't directly send the RSC stream to the worker, we use another `PassThrough` as a proxy to send data chunk by chunk by piping the RSC stream into it. Whenever we get a chunk from the RSC stream, we transfer it to the worker thread using `port1.postMessage`. On the worker side, the transferred `port2` receives the data.

Finally, when we get the HTML stream back on `port1`, we write it to the response chunk by chunk.

I know it might feel a bit complicated to understand how data is sent back and forth between the worker and the main thread. Try reading this explanation a couple more times along with the code. I'm confident it will start to make sense. ðŸ˜Š

Now, run the server. We should see the UI, right?

Yes! This time, no tricksâ€”you'll be able to see the Movie list UI. ðŸŽ‰

Before we move further, there is one small change that can be made to the application code which improves the user experience significantly.

```js filename="app.js" lineNumbers highlight="5"
import { getMovies } from './db';
import { MoviesList } from './movie-list';

export async function App() {
  const movies = await getMovies();

  return (
    <html lang='en'>
      <head>
        <meta charSet='UTF-8' />
        <meta name='viewport' content='width=device-width, initial-scale=1.0' />
        <title>Cine Score</title>
        <script src='https://cdn.tailwindcss.com'></script>
      </head>
      <body>
        <div className='flex min-h-[100dvh] flex-col bg-gray-900 text-gray-200'>
          <main className='container mx-auto max-w-lg flex-grow px-4 py-8'>
            <MoviesList movies={movies} />
          </main>
        </div>
      </body>
    </html>
  );
}
```

The promise returned by `getMovies` is awaited, which means the app cannot start rendering anything until the promise resolves. Although only the `MovieList` component depends on the data, the entire app is blocked from rendering. By making a small adjustment, the shell can be rendered immediately while only blocking the rendering of `MovieList`.

Things get even more interesting if we can provide a fallback while waiting for `MovieList` to render and swap the fallback with the actual content once it becomes available. Yes, we can achieve this thanks to a powerful primitive of React, `Suspense`.

#### Out of order Streaming

<Tabs defaultValue='app.js'>

<ScrollArea className='w-full'>
  <TabsList>
    <TabsTrigger value='app.js'>app.js</TabsTrigger>
    <TabsTrigger value='movie-list.js'>movie-list.js</TabsTrigger>
  </TabsList>
  <ScrollBar orientation='horizontal' />
</ScrollArea>

<TabsContent value='app.js'>

```js lineNumbers addition="1,8,9,23-29" deletion="6,7,22"
import { Suspense } from 'react';

import { getMovies } from './db';
import { MoviesList } from './movie-list';

export async function App() {
  const movies = await getMovies();
export function App() {
  const moviesPromise = getMovies();

  return (
    <html lang='en'>
      <head>
        <meta charSet='UTF-8' />
        <meta name='viewport' content='width=device-width, initial-scale=1.0' />
        <title>Cine Score</title>
        <script src='https://cdn.tailwindcss.com'></script>
      </head>
      <body>
        <div className='flex min-h-[100dvh] flex-col bg-gray-900 text-gray-200'>
          <main className='container mx-auto max-w-lg flex-grow px-4 py-8'>
            <MoviesList movies={movies} />
            <Suspense
              fallback={
                <div className='mx-auto size-8 animate-spin rounded-full border-2 border-gray-300 border-t-gray-500' />
              }
            >
              <MoviesList moviesPromise={moviesPromise} />
            </Suspense>
          </main>
        </div>
      </body>
    </html>
  );
}
```

</TabsContent>

<TabsContent value='movie-list.js'>

```js lineNumbers addition="4,5" deletion="3"
import { Vote } from './vote';

export function MoviesList({ movies, voteFn }) {
export async function MoviesList({ moviesPromise, voteFn }) {
  const movies = await moviesPromise;
  return (
    <ul
      className='max-h-[70vh] space-y-4 overflow-auto px-4'
      style={{
        scrollbarWidth: 'thin',
        scrollbarColor: '#4b5563 #1a1a1a',
      }}
    >
      {movies.length > 0 ? (
        movies.map((movie) => (
          <li
            key={movie.id}
            className='flex items-center justify-between rounded-lg bg-gray-800 p-4 shadow'
          >
            <div className='flex items-center space-x-4'>
              <Vote id={movie.id} action={voteFn} />
              <span className='text-xl font-bold'>{movie.votes}</span>
              <span className='text-gray-300'>{movie.title}</span>
            </div>
          </li>
        ))
      ) : (
        <li className='p-4 text-center text-gray-500'>No movies</li>
      )}
    </ul>
  );
}
```

</TabsContent>

</Tabs>

In the `App` component, the promise returned by `getMovies` is no longer awaited. Instead, it is passed down to the `MovieList` component. The `MovieList` component is now an async component that waits for the passed promise to resolve. It is wrapped in a `Suspense` boundary with a loading spinner as the fallback.

The shell of the app i.e. `head` tag, links to css along with the fallback of the suspended `MovieList` component, is immediately sent to the browser. While the server waits for `MovieList` component to render, the browser can start downloading the assets which are included in the app shell.

Now the real question is how do we swap out the fallback with actual HTML? The HTML stream is sequential meaning, once the server sends a chunk of HTML it can no longer be modified. The chunks can only be streamed in the order that they are generated.

The fallback is swapped out with the actual HTML using a trick implemented by the `Suspense` boundary. Suspended content is sent inside a hidden container, and a small JavaScript snippet is injected into the HTML as a `script` tag. This JavaScript swaps the fallback with the actual content. This is called **Out of order streaming**.

The suspended components can resolve in any order and react takes care of swapping the fallbacks with correct content. The only catch here is you need to have javascript enabled. If for some reason you have disabled the js execution, the fallbacks will not be swapped out.

One weird pattern I have implemented in the above code is instead of calling the `getMovies` function directly inside `MovieList` component, the promise is created in the `App` component and passed down as a prop. It is implemented this way because, promises are _hot_ in nature meaning the data fetching starts immediately upon the promise's creation, not when it is awaited. This way we initiate data fetching as early as possible and the `Suspense` boundary only waits for the data rather than initiating it. This pattern is called **Render as You Fetch** which is the recommend way to use `Suspense` for data fetching.

Now that we have set up the base for RSC, let's bring back the parts we left out when converting pure SSR into RSC, specifically the `Search` component and the vote functionality.

We've been ignoring an important aspect of the application. While async components for data fetching, `Suspense` boundaries for Out of order streaming and SSR are all great, where is React's main selling point client-side interactivity?

To enable this, we need to hydrate the server-generated HTML and activate React on the client side. Let's explore how we can achieve this.

### Hydration for Client Interactivity

When it comes to hydration, there are two essential pieces needed on the client side:

1. **Server-generated HTML**
2. **The React tree that was used to generate this HTML**

Getting a reference to the server-generated HTML is straightforward. In our case, since we're performing full-document SSR, the entire HTML document is generated on the server. The browser's `document` API provides a reference to this server-generated HTML.

The tricky part, however, is retrieving the React tree that was used to generate this HTML. This is because the React tree was created from the RSC payload.

In traditional SSR, we could import the same React tree on both the server and the client. However, in this case, we need to retrieve the RSC payload somehow. One approach could be to send another request to fetch just the RSC payload and then start the hydration process. However, this has three major disadvantages:

1. It creates a **client-server waterfall**, defeating the purpose of async server components.
2. It introduces **double data fetching**: once for the HTML and again for the RSC payload.
3. We **cannot start hydration** until the RSC payload request completes, leading to a bad user experience.

But what if we could fetch both the HTML and the RSC payload in a single request? That would eliminate these disadvantages. And yes, this is achievable!

#### Injecting the RSC Payload into the HTML Stream

We can retrieve both the HTML and the RSC payload in a single request by injecting the RSC payload into the HTML stream itself.

The following code is adapted from the [rsc-html-stream](https://www.npmjs.com/package/rsc-html-stream) package. Big thanks to [@devongovett](https://x.com/devongovett) for publishing this package. While I would have directly used the package, it relies on Web Streams instead of Node Streams. As a result, I made some changes, though the core logic remains the same.

There are two parts to this implementation:

1. **The server**, where we inject the RSC payload into the HTML stream.
2. **The client**, where we retrieve the injected chunks and convert them into a readable stream.

Here's the code:

<Tabs defaultValue='rsc-html-stream/server.js'>

<ScrollArea className='w-full'>
  <TabsList>
    {/* prettier-ignore */}
    <TabsTrigger value='rsc-html-stream/server.js'>rsc-html-stream/server.js</TabsTrigger>
    {/* prettier-ignore */}
    <TabsTrigger value='rsc-html-stream/client.js'>rsc-html-stream/client.js</TabsTrigger>
  </TabsList>
  <ScrollBar orientation='horizontal' />
</ScrollArea>

<TabsContent value='rsc-html-stream/server.js'>

{/* prettier-ignore */}
```js
// https://github.com/devongovett/rsc-html-stream/blob/main/server.js

const { Transform } = require('stream');
const { TextEncoder, TextDecoder } = require('util');

const encoder = new TextEncoder();
const trailer = '</body></html>';

function injectRSCPayload(rscStream) {
  const decoder = new TextDecoder();

  const { 
    promise: flightDataPromise, 
    resolve: resolveFlightDataPromise 
  } = Promise.withResolvers();

  const buffered = [];
  let startedRSC = false;
  let timeout = null;

  function flushBufferedChunks(transform) {
    for (const chunk of buffered) {
      let buf = decoder.decode(chunk);
      if (buf.endsWith(trailer)) {
        buf = buf.slice(0, -trailer.length);
      }
      transform.push(encoder.encode(buf));
    }

    buffered.length = 0;
    timeout = null;
  }

  const transform = new Transform({
    transform(chunk, encoding, callback) {
      buffered.push(chunk);
      if (timeout) {
        callback();
        return;
      }

      timeout = setTimeout(() => {
        flushBufferedChunks(transform);
        if (!startedRSC) {
          startedRSC = true;
          writeRSCStream(rscStream, transform)
            .then(resolveFlightDataPromise)
            .catch((err) => transform.destroy(err));
        }
      }, 0);

      callback();
    },

    async flush(callback) {
      try {
        await flightDataPromise;
        if (timeout) {
          clearTimeout(timeout);
          flushBufferedChunks(transform);
        }
        this.push(encoder.encode(trailer));
        callback();
      } catch (err) {
        callback(err);
      }
    },
  });

  return transform;
}

async function writeRSCStream(rscStream, transform) {
  const decoder = new TextDecoder('utf-8', { fatal: true });

  for await (const chunk of rscStream) {
    try {
      writeChunk(JSON.stringify(decoder.decode(chunk, { stream: true })), transform);
    } catch (err) {
      const base64 = JSON.stringify(Buffer.from(chunk).toString('base64'));
      writeChunk(`Uint8Array.from(Buffer.from(${base64}, 'base64'))`, transform);
    }
  }

  const remaining = decoder.decode();
  if (remaining.length) {
    writeChunk(JSON.stringify(remaining), transform);
  }
}

function writeChunk(chunk, transform) {
  transform.push(encoder.encode(`<script>${escapeScript(`(self.__RSC_PAYLOAD||=[]).push(${chunk})`)}</script>`));
}

function escapeScript(script) {
  return script.replace(/<!--/g, '<\\!--').replace(/<\/(script)/gi, '</\\$1');
}

module.exports = { injectRSCPayload };
```

</TabsContent>

<TabsContent value='rsc-html-stream/client.js'>

{/* prettier-ignore */}
```js
// https://github.com/devongovett/rsc-html-stream/blob/main/client.js

let streamController;
const encoder = new TextEncoder();

export const rscStream = new ReadableStream({
  start(controller) {
    const handleChunk = (chunk) => {
      if (typeof chunk === 'string') {
        controller.enqueue(encoder.encode(chunk));
      } else {
        controller.enqueue(chunk);
      }
    };
    window.__RSC_PAYLOAD ||= [];
    window.__RSC_PAYLOAD.forEach(handleChunk);
    window.__RSC_PAYLOAD.push = (chunk) => {
      handleChunk(chunk);
    };
    streamController = controller;
  },
});

const closeController = () => {
  if (streamController) {
    streamController.close();
    streamController = null;
  }
};

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', closeController);
} else {
  closeController();
}
```

</TabsContent>

</Tabs>

- The code creates a promise to track if the RSC payload injection is complete. An array called `buffered` stores all the HTML chunks pushed during the current tick of the event loop. This ensures all chunks are flushed before starting RSC payload injection to avoid injecting the payload between partial HTML chunks, which could result in invalid HTML.

- The `flushBufferedChunks` function iterates over each HTML chunk and checks if it ends with the trailer (`</body></html>`). If the trailer is found, it removes this part from the HTML since any content after the trailer is invalid. The trailer is manually appended back after the RSC payload injection is completed.

- Node.js [`Transform`](https://nodejs.org/api/stream.html#class-streamtransform) streams is used to transform the HTML stream. When an HTML chunk is received, it is pushed into the buffer. If an RSC payload injection is already scheduled to run on the next tick of the event loop, the function simply waits for the next HTML chunk. This delay ensures all valid HTML is flushed before starting the payload injection, preventing invalid HTML.

- On the next tick of the event loop, all buffered HTML chunks are flushed to the output stream using `flushBufferedChunks`. The buffer is then emptied, and the timeout is set to `null` to allow scheduling the flushing of buffered HTML chunks during the next tick of the event loop. This approach ensures the RSC payload injection does not produce invalid HTML.

- RSC payload injection starts by iterating through the RSC stream obtained by calling the `injectRSCPayload` function. For each chunk, a `<script>` tag is injected with the JSON-stringified version of the RSC chunk, which is pushed into a global array called `__RSC_PAYLOAD`. After the RSC payload injection is complete, the resolver of the `flightDataPromise` created earlier is called.

- In the `flush` method of the `Transform` implementation, the function waits for the RSC payload injection to complete by awaiting the `flightDataPromise`. If a timeout is scheduled to flush the HTML chunks, it clears the timeout and flushes all the buffered chunks immediately instead of waiting until the next tick of the event loop. Finally, the trailer is appended back to indicate the end of the HTML.

- On the client side, a new Readable Web stream is created. Each chunk in the global `__RSC_PAYLOAD` is enqueued for processing. Once the DOM content is loaded, indicating the entire document has been received, the stream is closed to signal the end of the RSC payload stream.

The processing in this code is complex and may require reading the explanation multiple times to fully understand. It took me several days to grasp this, so it is expected to take some time.

With this understanding of how to inject RSC payload into the HTML stream, these APIs can now be used to hydrate the application.

<Tabs defaultValue='fizz-worker.js'>

<ScrollArea className='w-full'>
  <TabsList>
    <TabsTrigger value='fizz-worker.js'>fizz-worker.js</TabsTrigger>
    <TabsTrigger value='client.js'>client.js</TabsTrigger>
  </TabsList>
  <ScrollBar orientation='horizontal' />
</ScrollArea>

<TabsContent value='fizz-worker.js'>

{/* prettier-ignore */}
```js lineNumbers addition="5,9,14,17,40,43-45" deletion="42"
const { parentPort } = require('worker_threads');
const { Writable, PassThrough } = require('stream');
const ReactServerDOMWebpackClient = require('react-server-dom-webpack/client');
const ReactDOMServer = require('react-dom/server');
const { injectRSCPayload } = require('./rsc-html-stream/server');

parentPort.on('message', async (request) => {
  const htmlConsumerRSCStream = new PassThrough();
  const payloadConsumerRSCStream = new PassThrough();

  request.port.on('message', (message) => {
    if (message.type === 'data') {
      htmlConsumerRSCStream.write(message.data);
      payloadConsumerRSCStream.write(message.data);
    } else if (message.type === 'end') {
      htmlConsumerRSCStream.end();
      payloadConsumerRSCStream.end();
    }
  });

  const writableStream = new Writable({
    write(chunk, encoding, callback) {
      request.port.postMessage({
        type: 'data',
        data: chunk,
      });
      callback();
    },
    final(callback) {
      request.port.postMessage({ type: 'end' });
      callback();
    },
  });

  const tree = await ReactServerDOMWebpackClient.createFromNodeStream(htmlConsumerRSCStream, {
    moduleMap: {},
  });

  const htmlStream = ReactDOMServer.renderToPipeableStream(tree, {
    bootstrapScripts: ['/client.js'],
    onShellReady: () => {
      htmlStream.pipe(writableStream);
      const htmlStreamTransformer = injectRSCPayload(payloadConsumerRSCStream)
      const htmlStreamWithRSCPayload = htmlStream.pipe(htmlStreamTransformer)
      htmlStreamWithRSCPayload.pipe(writableStream);
    },
  });
});
```

</TabsContent>

<TabsContent value='client.js'>

{/* prettier-ignore */}
```js lineNumbers addition="1,3,5-11" deletion="4"
import React from 'react';
import ReactDOMClient from 'react-dom/client';
import ReactServerDOMWebpackClient from 'react-server-dom-webpack/client';
import { App } from './app';
import { rscStream } from './rsc-html-stream/client';

const reactTreePromise = ReactServerDOMWebpackClient.createFromReadableStream(rscStream);

function App() {
  return React.use(rscPayloadPromise);
}

ReactDOMClient.hydrateRoot(document, <App />);
```

</TabsContent>

</Tabs>

Since we need the RSC stream for injecting the RSC payload we create one more copy of the RSC stream using another `PassThrough`. We get the transform by calling the `injectRSCPayload` function and passing this RSC stream copy as the argument.

The HTML stream is piped to this transformer to get back the Transformed HTML stream which has injected RSC payload. Then this transformed html stream is piped to the writeable

On client, the rscStream is imported and passed to `createFromReadableStream` API of `react-server-dom-webpack/client`. In the `App` component, the react tree promise is unwrapped using the `use` API.

Now that we have the React tree we can hydrate the Server generated HTML using `hydrateRoot` API.

Let's take a closer look at what happens during the hydration process. The `createFromReadableStream` function takes in the RSC stream (i.e., the RSC payload) and provides the React tree. Earlier, while discussing the [RSC Payload](#rsc-payload), I mentioned that the idea of RSCs running only on the server and never on the client is **partially true**. This is because we need the entire **React tree** to create the **Fiber tree** for reconciliation.

Here's what actually happens: RSCs are not hydrated. This is because RSCs are stateless by design. If we examine the RSC payload of a component, it includes metadata such as the environment, owner, props, and the returned JSX of that component. However, there is no information stored about how the JSX is generated. This makes the RSC payload inherently stateless. Since these components are stateless, React can safely skip the hydration process for them. This is called **Partial Hydration**.

With this optimization, the application gets hydrated more quickly and can prioritize hydrating individual components based on user interaction, leading to a better user experience.

You won't observe any difference from the previous version since we don't have any interactive components yet. It'll all make sense in sometime.

Everything needed for interactivity is in place so let's bring back the `Search` component.

### Search Component

In a traditional SSR React app, we used state to store the list of movies and filtered the list based on the search query to achieve search functionality. However, with RSCs, we know that they are stateless and not hydrated. So, how do we update the list based on the search query?

This requires shifting our thinking from a **client-first approach** to a **server-first approach**. To understand this better, let's briefly revisit React's **reconciliation process**.

Reconciliation is the process by which React updates the UI when the application's state change.

1. When a state update occurs, React generates a new React tree that represents the UI after the update.
2. React then compares this new tree with the existing **Fiber tree**.
3. React determines the diff between the new tree and the Fiber tree and updates the parts that have changed.
4. Once reconciliation is complete, these changes are applied to the actual DOM.

To make the search functionality work, we need to update the **React tree** with only the movies that match the search query. If we can obtain an updated React tree that contains only the filtered movies, the search functionality is effectively handled.

If we reverse-engineer the process, we see that:

- The source of the React element tree is the **RSC payload**.
- The source of the RSC payload is the **server**.

Since RSCs are **stateless**, we cannot rely on traditional client-side state management to update the UI. Instead, we need to **refetch the RSC payload** from the server based on the search query. When the new RSC payload arrives, we can use it to recreate the React tree and trigger the reconciliation process.

Let's update the code to implement this solution.

<Tabs defaultValue='client.js'>

<ScrollArea className='w-full'>
  <TabsList>
    <TabsTrigger value='client.js'>client.js</TabsTrigger>
    <TabsTrigger value='search.js'>search.js</TabsTrigger>
    <TabsTrigger value='server.js'>server.js</TabsTrigger>
    <TabsTrigger value='app.js'>app.js</TabsTrigger>
  </TabsList>
  <ScrollBar orientation='horizontal' />
</ScrollArea>

<TabsContent value='client.js'>

{/* prettier-ignore */}
```js lineNumbers addition="10-24" deletion="9"
import React from 'react';
import ReactDOMClient from 'react-dom/client';
import ReactServerDOMWebpackClient from 'react-server-dom-webpack/client';
import { rscStream } from './rsc-html-stream/client';

const reactTreePromise = ReactServerDOMWebpackClient.createFromReadableStream(rscStream);

function App() {
  return React.use(rscPayloadPromise);
  const [tree, setTree] = React.useState(React.use(rscPayloadPromise));

  React.useEffect(() => {
    window.__updateTree = (tree) => {
      React.startTransition(() => {
        setTree(tree);
      })
    };

    return () => {
      window.__setTree = null;
    };
  }, []);

  return tree;
}

ReactDOMClient.hydrateRoot(document, <App />);
```

</TabsContent>

<TabsContent value='search.js'>

```js lineNumbers addition="2,5,13-21" deletion="4,10-12"
import { useTransition } from 'react';
import ReactServerDOMWebpackClient from 'react-server-dom-webpack/client';

export function Search({ onSearch }) {
export function Search() {
  const [isSearching, startSearching] = useTransition();

  const handleChange = (e) => {
    const query = e.target.value;
    startSearching(() => {
      onSearch(query);
    });
    startSearching(async () => {
      const headers = new Headers();
      headers.set('Accept', 'text/x-component');

      const response = fetch(`/?query=${query}`, { headers });
      const tree = await ReactServerDOMWebpackClient.createFromFetch(response);

      window.__updateTree?.(tree);
    });
  };

  return (
    <search className='relative mb-6 px-4'>
      <form>
        <input
          type='search'
          placeholder='Search movies...'
          className='w-full rounded-md border border-gray-700 bg-gray-800 px-8 py-2 text-gray-300 placeholder-gray-500 focus:ring-2 focus:ring-indigo-500 focus:outline-none'
          onChange={handleChange}
        />
      </form>
      {isSearching && (
        <div className='absolute top-1/2 right-6 -translate-y-1/2'>
          <div className='size-4 animate-spin rounded-full border-2 border-gray-300 border-t-gray-500' />
        </div>
      )}
    </search>
  );
}
```

</TabsContent>

<TabsContent value='server.js'>

{/* prettier-ignore */}
```js lineNumbers addition="27,30-34" deletion="26"
require('@babel/register')({
  ignore: [/[\\\/](dist|node_modules)[\\\/]/],
  presets: [['@babel/preset-react', { runtime: 'automatic' }]],
  plugins: ['@babel/plugin-transform-modules-commonjs'],
});

const express = require('express');
const path = require('path');
const React = require('react');
const ReactServerDOMWebpackServer = require('react-server-dom-webpack/server');
const { Worker, MessageChannel } = require('worker_threads');
const { PassThrough } = require('stream');
const { App } = require('./app');

const app = express();
const PORT = 1234;

const fizzWorker = new Worker(path.resolve(__dirname, './fizz-worker.js'), {
  execArgv: ['--conditions', 'default'],
});

app.use(express.static(path.join(__dirname, 'dist')));

async function handleRequest(req, res) {
  try {
    const tree = React.createElement(App);
    const tree = React.createElement(App, { searchParams: req.query });
    const rscStream = ReactServerDOMWebpackServer.renderToPipeableStream(tree);

    if (req.headers.accept === 'text/x-component') {
      res.setHeader('Content-Type', 'text/x-component');
      rscStream.pipe(res);
      return;
    }

    res.setHeader('Content-Type', 'text/html');

    const { port1, port2 } = new MessageChannel();

    const request = {
      port: port2,
    };

    fizzWorker.postMessage(request, [port2]);

    const passThroughRSCStream = new PassThrough();
    rscStream.pipe(passThroughRSCStream);

    passThroughRSCStream.on('data', (data) => {
      port1.postMessage({
        type: 'data',
        data,
      });
    });

    passThroughRSCStream.on('end', () => {
      port1.postMessage({
        type: 'end',
      });
    });

    port1.on('message', (message) => {
      if (message.type === 'data') {
        res.write(message.data);
      } else if (message.type === 'end') {
        res.end();
      }
    });
  } catch (error) {
    console.log({ error });
    res.status(500).send('Internal Server Error');
  }
}

app.get('/', handleRequest);

app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});
```

</TabsContent>

<TabsContent value='app.js'>

```js lineNumbers addition="5,9,10,23" deletion="7,8"
import { Suspense } from 'react';

import { getMovies } from './db';
import { MoviesList } from './movie-list';
import { Search } from './search';

export function App() {
  const moviesPromise = getMovies();
export function App({ searchParams }) {
  const moviesPromise = getMovies(searchParams.query);

  return (
    <html lang='en'>
      <head>
        <meta charSet='UTF-8' />
        <meta name='viewport' content='width=device-width, initial-scale=1.0' />
        <title>Cine Score</title>
        <script src='https://cdn.tailwindcss.com'></script>
      </head>
      <body>
        <div className='flex min-h-[100dvh] flex-col bg-gray-900 text-gray-200'>
          <main className='container mx-auto max-w-lg flex-grow px-4 py-8'>
            <Search />
            <Suspense
              fallback={
                <div className='mx-auto size-8 animate-spin rounded-full border-2 border-gray-300 border-t-gray-500' />
              }
            >
              <MoviesList moviesPromise={moviesPromise} />
            </Suspense>
          </main>
        </div>
      </body>
    </html>
  );
}
```

</TabsContent>

</Tabs>

In the client entry point, the `App` component is modified to hold the React tree in state so that we can trigger reconciliation when we update this state with a new React tree. In the effect, the `__updateTree` function is exposed on the global `window` object to make it easy to access in the application code. There is a better way to handle this instead of exposing the updater function on the `window` object, which we will cover later.

> The state update is done inside a transition. This is essential for reconciliation to work properly. I don't have an exact answer for why this must be done in a transition. If you have an answer, please feel free to update this blog or add a comment. It'll help me and other readers as well.

In the `Search` component, whenever the query is updated, we make a fetch request with the query as the search parameter. We also set the `Accept` header to `text/x-component` to indicate to the server that we expect only the RSC payload, not HTML.

> Note: `text/x-component` is the content type of RSC payload used by all the RSC frameworks

The response is passed to the `createFromFetch` API of `react-server-dom-webpack/client` to retrieve the React tree. The `__updateTree` function, which is exposed on the global `window` object, is then called with the new React tree. This triggers a state update, and the UI updates as a result of reconciliation.

On the server, the search parameters are passed as props to the `App` component. if the `Accept` header is `text/x-component` we pipe the rsc stream directly to the response instead of forwarding to SSR worker. The `App` component is updated to render the `Search` component, and the query received as a prop is forwarded to the `getMovies` function. The `getMovies` function is already configured to apply filtering based on the query.

> Please use search parameters for state as much as possible. It simplifies many complexitiesâ€”ensuring a single source of truth across the client and server, keeping the app state in sync with the URL, and making the app state shareable and ability to bookmark.

Now, if we start the server and visit the browserâ€”oh, wait, the server itself won't start. Once again, we've hit another error:

> Error: (0 , \_react.useTransition) is not a function or its return value is not iterable.

This issue is related to the `useTransition` hook used in the `Search` component. To debug this error, let's go back to the definition of React Server Components.

RSCs is a serialization/deserialization capability that supports a superset of the types defined by the structured clone algorithm. The return value of `useTransition` is an array with two values. The first value is a `boolean` that indicates if a transition is pending, and the second value is a function used to trigger the transition. The key takeaway here is that this function is not serializableâ€”and if you recall, I never mentioned that functions are serializable when defining RSCs.

Similarly, if you look at the `handleChange` event handler defined inside the component body, you'll notice that it's also a function. Since functions cannot be serialized, how do we solve this problem?

We should simply avoid serializing these kinds of componentsâ€”those that use client-side APIs like state, effects, transitions, event handlers, or anything that is not serializable by the Flight renderer. We do this by ensuring these components are not rendered in the `react-server` environment but instead in a non-`react-server` environment.

So, what is this non-`react-server` environment? If you look carefully, we have been using two non-`react-server` environments all along: the SSR worker and the browser.

Let's explore how to implement this approach next.
